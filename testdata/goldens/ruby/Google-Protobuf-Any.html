<!DOCTYPE html>
<html devsite="">
  <head>
    <meta name="project_path" value="/ruby/_project.yaml">
    <meta name="book_path" value="/ruby/_book.yaml">
  </head>
  <body>
    {% verbatim %}
    <div>
      <article data-uid="Google::Protobuf::Any">
<h1 class="page-title">Cloud Vision V1 API - Class Google::Protobuf::Any (v0.6.4)</h1>
  
  
  <div class="markdown level0 summary"><p>Reference documentation and code samples for the Cloud Vision V1 API class Google::Protobuf::Any.</p><p><code>Any</code> contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.</p>

<p>Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.</p>

<p>Example 1: Pack and unpack a message in C++.</p>

<pre><code>Foo foo = ...;
Any any;
any.PackFrom(foo);
...
if (any.UnpackTo(&amp;foo)) {
  ...
}
</code></pre>

<p>Example 2: Pack and unpack a message in Java.</p>

<pre><code>Foo foo = ...;
Any any = Any.pack(foo);
...
if (any.is(Foo.class)) {
  foo = any.unpack(Foo.class);
}
</code></pre>

<p>Example 3: Pack and unpack a message in Python.</p>

<pre><code>foo = Foo(...)
any = Any()
any.Pack(foo)
...
if any.Is(Foo.DESCRIPTOR):
  any.Unpack(foo)
  ...
</code></pre>

<p>Example 4: Pack and unpack a message in Go</p>

<pre><code> foo := &amp;pb.Foo{...}
 any, err := anypb.New(foo)
 if err != nil {
   ...
 }
 ...
 foo := &amp;pb.Foo{}
 if err := any.UnmarshalTo(foo); err != nil {
   ...
 }
</code></pre>

<p>The pack methods provided by protobuf library will by default use
&#39;type.googleapis.com/full.type.name&#39; as the type URL and the unpack
methods only use the fully qualified type name after the last &#39;/&#39;
in the type URL, for example &quot;foo.bar.com/x/y.z&quot; will yield type
name &quot;y.z&quot;.</p>
<h2>JSON</h2>

<p>The JSON representation of an <code>Any</code> value uses the regular
representation of the deserialized, embedded message, with an
additional field <code>@type</code> which contains the type URL. Example:</p>

<pre><code>package google.profile;
message Person {
  string first_name = 1;
  string last_name = 2;
}

{
  &quot;@type&quot;: &quot;type.googleapis.com/google.profile.Person&quot;,
  &quot;firstName&quot;: &lt;string&gt;,
  &quot;lastName&quot;: &lt;string&gt;
}
</code></pre>

<p>If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
<code>value</code> which holds the custom JSON in addition to the <code>@type</code>
field. Example (for message [google.protobuf.Duration][]):</p>

<pre><code>{
  &quot;@type&quot;: &quot;type.googleapis.com/google.protobuf.Duration&quot;,
  &quot;value&quot;: &quot;1.212s&quot;
}
</code></pre></div>
  <div class="inheritance">
    <h2>Inherits</h2>
    <ul>
      <li>
        Object
      </li>
    </ul>
  </div>
  <div class="inheritance">
    <h2>Extended By</h2>
    <ul>
      <li>
        Google::Protobuf::MessageExts::ClassMethods
      </li>
    </ul>
  </div>
  <div class="inheritance">
    <h2>Includes</h2>
    <ul>
      <li>
        Google::Protobuf::MessageExts
      </li>
    </ul>
  </div>
  <h2 id="methods">Methods
  </h2>
  <h3 id="Google__Protobuf__Any_type_url_instance_" data-uid="Google::Protobuf::Any#type_url(instance)" class="notranslate">#type_url</h3>
  <div class="codewrapper">
    <pre class="prettyprint"><code>def type_url() -&gt; ::String</code></pre>
  </div>
  <div class="level1 summary">
    <strong>Returns</strong>
    <ul>
      <li>
        (::String) — A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one &quot;/&quot; character. The last segment of the URL&#39;s path must represent
the fully qualified name of the type (as in
<code>path/google.protobuf.Duration</code>). The name should be in a canonical form
(e.g., leading &quot;.&quot; is not accepted).<p>

<p>In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme <code>http</code>, <code>https</code>, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:</p>

<ul>
<li>If no scheme is provided, <code>https</code> is assumed.</li>
<li>An HTTP GET on the URL must yield a [google.protobuf.Type][]
value in binary format, or produce an error.</li>
<li>Applications are allowed to cache lookup results based on the
URL, or have them precompiled into a binary to avoid any
lookup. Therefore, binary compatibility needs to be preserved
on changes to types. (Use versioned type names to manage
breaking changes.)</li>
</ul>

<p>Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com.</p>

<p>Schemes other than <code>http</code>, <code>https</code> (or the empty scheme) might be
used with implementation specific semantics.
      </li>
    </ul>
  </div>
  <h3 id="Google__Protobuf__Any_type_url__instance_" data-uid="Google::Protobuf::Any#type_url=(instance)" class="notranslate">#type_url=</h3>
  <div class="codewrapper">
    <pre class="prettyprint"><code>def type_url=(value) -&gt; ::String</code></pre>
  </div>
  <div class="level1 summary">
    <strong>Parameter</strong>
    <ul>
      <li>
        <strong>value</strong> (::String) — A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one &quot;/&quot; character. The last segment of the URL&#39;s path must represent
the fully qualified name of the type (as in
<code>path/google.protobuf.Duration</code>). The name should be in a canonical form
(e.g., leading &quot;.&quot; is not accepted).<p>

<p>In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme <code>http</code>, <code>https</code>, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:</p>

<ul>
<li>If no scheme is provided, <code>https</code> is assumed.</li>
<li>An HTTP GET on the URL must yield a [google.protobuf.Type][]
value in binary format, or produce an error.</li>
<li>Applications are allowed to cache lookup results based on the
URL, or have them precompiled into a binary to avoid any
lookup. Therefore, binary compatibility needs to be preserved
on changes to types. (Use versioned type names to manage
breaking changes.)</li>
</ul>

<p>Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com.</p>

<p>Schemes other than <code>http</code>, <code>https</code> (or the empty scheme) might be
used with implementation specific semantics.
      </li>
    </ul>
  </div>
  <div class="level1 summary">
    <strong>Returns</strong>
    <ul>
      <li>
        (::String) — A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one &quot;/&quot; character. The last segment of the URL&#39;s path must represent
the fully qualified name of the type (as in
<code>path/google.protobuf.Duration</code>). The name should be in a canonical form
(e.g., leading &quot;.&quot; is not accepted).<p>

<p>In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme <code>http</code>, <code>https</code>, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:</p>

<ul>
<li>If no scheme is provided, <code>https</code> is assumed.</li>
<li>An HTTP GET on the URL must yield a [google.protobuf.Type][]
value in binary format, or produce an error.</li>
<li>Applications are allowed to cache lookup results based on the
URL, or have them precompiled into a binary to avoid any
lookup. Therefore, binary compatibility needs to be preserved
on changes to types. (Use versioned type names to manage
breaking changes.)</li>
</ul>

<p>Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com.</p>

<p>Schemes other than <code>http</code>, <code>https</code> (or the empty scheme) might be
used with implementation specific semantics.
      </li>
    </ul>
  </div>
  <h3 id="Google__Protobuf__Any_value_instance_" data-uid="Google::Protobuf::Any#value(instance)" class="notranslate">#value</h3>
  <div class="codewrapper">
    <pre class="prettyprint"><code>def value() -&gt; ::String</code></pre>
  </div>
  <div class="level1 summary">
    <strong>Returns</strong>
    <ul>
      <li>
        (::String) — Must be a valid serialized protocol buffer of the above specified type.
      </li>
    </ul>
  </div>
  <h3 id="Google__Protobuf__Any_value__instance_" data-uid="Google::Protobuf::Any#value=(instance)" class="notranslate">#value=</h3>
  <div class="codewrapper">
    <pre class="prettyprint"><code>def value=(value) -&gt; ::String</code></pre>
  </div>
  <div class="level1 summary">
    <strong>Parameter</strong>
    <ul>
      <li>
        <strong>value</strong> (::String) — Must be a valid serialized protocol buffer of the above specified type.
      </li>
    </ul>
  </div>
  <div class="level1 summary">
    <strong>Returns</strong>
    <ul>
      <li>
        (::String) — Must be a valid serialized protocol buffer of the above specified type.
      </li>
    </ul>
  </div>
</article>
    </div>
    {% endverbatim %}
  </body>
</html>
