<!DOCTYPE html>
<html devsite="">
  <head>
    <meta name="project_path" value="/ruby/_project.yaml">
    <meta name="book_path" value="/ruby/_book.yaml">
  </head>
  <body>
    {% verbatim %}
    <div>
      <article data-uid="Google::Protobuf::Any">
<h1 class="page-title">Class Google::Protobuf::Any
</h1>
  
  
  <div class="markdown level0 summary"><p><code>Any</code> contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.</p>
<p>Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.</p>
<p>Example 1: Pack and unpack a message in C++.</p>
<pre class="prettyprint lang-rb">Foo foo = ...;
Any any;
any.PackFrom(foo);
...
if (any.UnpackTo(&foo)) {
  ...
}</pre>

<p>Example 2: Pack and unpack a message in Java.</p>
<pre class="prettyprint lang-rb">Foo foo = ...;
Any any = Any.pack(foo);
...
if (any.is(Foo.class)) {
  foo = any.unpack(Foo.class);
}

 Example 3: Pack and unpack a message in Python.

foo = Foo(...)
any = Any()
any.Pack(foo)
...
if any.Is(Foo.DESCRIPTOR):
  any.Unpack(foo)
  ...

 Example 4: Pack and unpack a message in Go

 foo := &pb.Foo{...}
 any, err := anypb.New(foo)
 if err != nil {
   ...
 }
 ...
 foo := &pb.Foo{}
 if err := any.UnmarshalTo(foo); err != nil {
   ...
 }</pre>

<p>The pack methods provided by protobuf library will by default use
&#39;type.googleapis.com/full.type.name&#39; as the type URL and the unpack
methods only use the fully qualified type name after the last &#39;/&#39;
in the type URL, for example &quot;foo.bar.com/x/y.z&quot; will yield type
name &quot;y.z&quot;.</p>
<h1 id="json">JSON</h1>
<p>The JSON representation of an <code>Any</code> value uses the regular
representation of the deserialized, embedded message, with an
additional field <code>@type</code> which contains the type URL. Example:</p>
<pre class="prettyprint lang-rb">package google.profile;
message Person {
  string first_name = 1;
  string last_name = 2;
}

{
  "@type": "type.googleapis.com/google.profile.Person",
  "firstName": <string>,
  "lastName": <string>
}</string></string></pre>

<p>If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
<code>value</code> which holds the custom JSON in addition to the <code>@type</code>
field. Example (for message [google.protobuf.Duration][]):</p>
<pre class="prettyprint lang-rb">{
  "@type": "type.googleapis.com/google.protobuf.Duration",
  "value": "1.212s"
}</pre></div>
  <h2 id="methods">Methods
  </h2>
  <h3 id="Google__Protobuf__Any_type_url" data-uid="Google::Protobuf::Any#type_url" class="notranslate">#type_url</h3>
  <div class="codewrapper">
    <pre><code class="prettyprint">#type_url =&gt; ::String</code></pre>
  </div>
  <strong>Returns</strong>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">::String</span></td>
        <td><p>A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one &quot;/&quot; character. The last segment of the URL&#39;s path must represent
the fully qualified name of the type (as in
<code>path/google.protobuf.Duration</code>). The name should be in a canonical form
(e.g., leading &quot;.&quot; is not accepted).</p>
<p>In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme <code>http</code>, <code>https</code>, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:</p>
<ul>
<li>If no scheme is provided, <code>https</code> is assumed.</li>
<li>An HTTP GET on the URL must yield a [google.protobuf.Type][]
value in binary format, or produce an error.</li>
<li>Applications are allowed to cache lookup results based on the
URL, or have them precompiled into a binary to avoid any
lookup. Therefore, binary compatibility needs to be preserved
on changes to types. (Use versioned type names to manage
breaking changes.)</li>
</ul>
<p>Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com.</p>
<p>Schemes other than <code>http</code>, <code>https</code> (or the empty scheme) might be
used with implementation specific semantics.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="Google__Protobuf__Any_type_url_" data-uid="Google::Protobuf::Any#type_url=" class="notranslate">#type_url=</h3>
  <div class="codewrapper">
    <pre><code class="prettyprint">#type_url=(value) =&gt; ::String</code></pre>
  </div>
  <strong>Returns</strong>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">::String</span></td>
        <td><p>A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one &quot;/&quot; character. The last segment of the URL&#39;s path must represent
the fully qualified name of the type (as in
<code>path/google.protobuf.Duration</code>). The name should be in a canonical form
(e.g., leading &quot;.&quot; is not accepted).</p>
<p>In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme <code>http</code>, <code>https</code>, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:</p>
<ul>
<li>If no scheme is provided, <code>https</code> is assumed.</li>
<li>An HTTP GET on the URL must yield a [google.protobuf.Type][]
value in binary format, or produce an error.</li>
<li>Applications are allowed to cache lookup results based on the
URL, or have them precompiled into a binary to avoid any
lookup. Therefore, binary compatibility needs to be preserved
on changes to types. (Use versioned type names to manage
breaking changes.)</li>
</ul>
<p>Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com.</p>
<p>Schemes other than <code>http</code>, <code>https</code> (or the empty scheme) might be
used with implementation specific semantics.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="Google__Protobuf__Any_value" data-uid="Google::Protobuf::Any#value" class="notranslate">#value</h3>
  <div class="codewrapper">
    <pre><code class="prettyprint">#value =&gt; ::String</code></pre>
  </div>
  <strong>Returns</strong>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">::String</span></td>
        <td><p>Must be a valid serialized protocol buffer of the above specified type.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="Google__Protobuf__Any_value_" data-uid="Google::Protobuf::Any#value=" class="notranslate">#value=</h3>
  <div class="codewrapper">
    <pre><code class="prettyprint">#value=(value) =&gt; ::String</code></pre>
  </div>
  <strong>Returns</strong>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">::String</span></td>
        <td><p>Must be a valid serialized protocol buffer of the above specified type.</p>
</td>
      </tr>
    </tbody>
  </table>
</article>
    </div>
    {% endverbatim %}
  </body>
</html>
